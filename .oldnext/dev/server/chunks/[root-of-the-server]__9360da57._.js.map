{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/services/embeddingService.ts"],"sourcesContent":["import OpenAI from 'openai';\r\n\r\n// Initialize OpenAI client\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport class EmbeddingService {\r\n    /**\r\n     * Generate embedding vector for text using OpenAI's text-embedding-3-small model\r\n     */\r\n    static async generateEmbedding(text: string): Promise<number[]> {\r\n        try {\r\n            console.log('üß† Generating embedding for text (length:', text.length, 'chars)');\r\n\r\n            // Truncate text if too long (max ~8000 tokens ‚âà 32000 chars)\r\n            const truncatedText = text.substring(0, 32000);\r\n\r\n            const response = await openai.embeddings.create({\r\n                model: 'text-embedding-3-small',\r\n                input: truncatedText,\r\n            });\r\n\r\n            const embedding = response.data[0].embedding;\r\n            console.log('‚úÖ Embedding generated (dimensions:', embedding.length, ')');\r\n\r\n            return embedding;\r\n        } catch (error) {\r\n            console.error('‚ùå Embedding generation failed:', error);\r\n            throw new Error(`Failed to generate embedding: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate cosine similarity between two embedding vectors\r\n     * Returns a value between -1 and 1, where 1 means identical, 0 means orthogonal, -1 means opposite\r\n     */\r\n    static calculateCosineSimilarity(vec1: number[], vec2: number[]): number {\r\n        if (vec1.length !== vec2.length) {\r\n            throw new Error('Vectors must have the same dimensions');\r\n        }\r\n\r\n        let dotProduct = 0;\r\n        let norm1 = 0;\r\n        let norm2 = 0;\r\n\r\n        for (let i = 0; i < vec1.length; i++) {\r\n            dotProduct += vec1[i] * vec2[i];\r\n            norm1 += vec1[i] * vec1[i];\r\n            norm2 += vec2[i] * vec2[i];\r\n        }\r\n\r\n        const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n\r\n        if (magnitude === 0) {\r\n            return 0;\r\n        }\r\n\r\n        const similarity = dotProduct / magnitude;\r\n\r\n        console.log('üìä Cosine similarity:', similarity.toFixed(4));\r\n\r\n        return similarity;\r\n    }\r\n\r\n    /**\r\n     * Prepare text for embedding generation by combining relevant fields\r\n     */\r\n    static prepareJobText(job: any): string {\r\n        const parts = [\r\n            job.title || '',\r\n            job.description || '',\r\n            job.department || '',\r\n            job.location || '',\r\n            (job.requiredSkills || []).join(', '),\r\n            (job.requiredLicenses || []).join(', '),\r\n            job.requirements ? (Array.isArray(job.requirements) ? job.requirements.join(', ') : job.requirements) : ''\r\n        ];\r\n\r\n        return parts.filter(p => p).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Prepare candidate text for embedding generation\r\n     */\r\n    static prepareCandidateText(candidate: any): string {\r\n        const parts = [\r\n            candidate.name || '',\r\n            `${candidate.experience || 0} years of experience`,\r\n            (candidate.skills || []).join(', '),\r\n            (candidate.licenses || []).join(', '),\r\n            candidate.location || '',\r\n            candidate.rawText || ''\r\n        ];\r\n\r\n        return parts.filter(p => p).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Generate embeddings for multiple texts in a single batch request\r\n     * More efficient than individual requests\r\n     */\r\n    static async generateBatchEmbeddings(texts: string[]): Promise<number[][]> {\r\n        try {\r\n            if (texts.length === 0) return [];\r\n\r\n            console.log(`üß† Generating ${texts.length} embeddings in batch...`);\r\n\r\n            // Truncate each text if too long\r\n            const truncatedTexts = texts.map(text => text.substring(0, 32000));\r\n\r\n            const response = await openai.embeddings.create({\r\n                model: 'text-embedding-3-small',\r\n                input: truncatedTexts,\r\n            });\r\n\r\n            const embeddings = response.data.map(item => item.embedding);\r\n            console.log(`‚úÖ Generated ${embeddings.length} embeddings`);\r\n\r\n            return embeddings;\r\n        } catch (error) {\r\n            console.error('‚ùå Batch embedding generation failed:', error);\r\n            throw new Error(`Failed to generate batch embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate embeddings for individual skills/requirements\r\n     * Returns a map of skill -> embedding\r\n     */\r\n    static async generateSkillEmbeddings(skills: string[]): Promise<Map<string, number[]>> {\r\n        if (skills.length === 0) return new Map();\r\n\r\n        const embeddings = await this.generateBatchEmbeddings(skills);\r\n        const skillEmbeddingMap = new Map<string, number[]>();\r\n\r\n        skills.forEach((skill, index) => {\r\n            skillEmbeddingMap.set(skill, embeddings[index]);\r\n        });\r\n\r\n        return skillEmbeddingMap;\r\n    }\r\n\r\n    /**\r\n     * Calculate semantic similarity between a candidate skill and a required skill\r\n     * Returns a similarity score between 0 and 1\r\n     */\r\n    static calculateSkillSimilarity(\r\n        candidateSkillEmbedding: number[],\r\n        requiredSkillEmbedding: number[]\r\n    ): number {\r\n        const similarity = this.calculateCosineSimilarity(candidateSkillEmbedding, requiredSkillEmbedding);\r\n        // Normalize to 0-1 range (cosine similarity is -1 to 1)\r\n        return Math.max(0, similarity);\r\n    }\r\n\r\n    /**\r\n     * Find the best matching candidate skill for a required skill\r\n     * Returns the best match with its similarity score\r\n     */\r\n    static findBestSkillMatch(\r\n        requiredSkillEmbedding: number[],\r\n        candidateSkillEmbeddings: Map<string, number[]>\r\n    ): { skill: string; similarity: number } | null {\r\n        let bestMatch: { skill: string; similarity: number } | null = null;\r\n\r\n        for (const [skill, embedding] of candidateSkillEmbeddings.entries()) {\r\n            const similarity = this.calculateSkillSimilarity(embedding, requiredSkillEmbedding);\r\n\r\n            if (!bestMatch || similarity > bestMatch.similarity) {\r\n                bestMatch = { skill, similarity };\r\n            }\r\n        }\r\n\r\n        return bestMatch;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/services/matchingService.ts"],"sourcesContent":["import { EmbeddingService } from './embeddingService';\r\n\r\nexport class MatchingEngine {\r\n    static async calculateMatch(candidate: any, job: any) {\r\n        let score = 0;\r\n        const reasons = [];\r\n\r\n        // 1. Experience match (25 points max)\r\n        const minExperience = job.minExperience || 0;\r\n\r\n        if (minExperience === 0) {\r\n            // If no experience required, give full points\r\n            score += 25;\r\n            reasons.push('Experience: Met (No minimum required)');\r\n        } else if (candidate.experience >= minExperience) {\r\n            // If they meet the requirement\r\n            const ratio = candidate.experience / minExperience;\r\n            const expScore = Math.min(25, 15 + (ratio - 1) * 10);\r\n            score += expScore;\r\n            reasons.push(`Experience: ${candidate.experience} years (Required: ${minExperience})`);\r\n        } else {\r\n            // Partial score for being close\r\n            const ratio = candidate.experience / minExperience;\r\n            const expScore = ratio * 15;\r\n            score += expScore;\r\n            reasons.push(`Experience: ${candidate.experience} years (Under qualified)`);\r\n        }\r\n\r\n        // 2. Semantic Skills Match (30 points max - increased from 20)\r\n        let skillsScore = 0;\r\n        const matchedSkills: any[] = [];\r\n        const skillDetails: string[] = [];\r\n\r\n        if (job.requiredSkills && job.requiredSkills.length > 0) {\r\n            try {\r\n                // Generate embeddings for required skills if not already present\r\n                if (!job.skillEmbeddings) {\r\n                    job.skillEmbeddings = await EmbeddingService.generateSkillEmbeddings(job.requiredSkills);\r\n                }\r\n\r\n                // Generate embeddings for candidate skills if not already present\r\n                if (!candidate.skillEmbeddings) {\r\n                    candidate.skillEmbeddings = await EmbeddingService.generateSkillEmbeddings(candidate.skills || []);\r\n                }\r\n\r\n                // For each required skill, find the best matching candidate skill\r\n                for (const requiredSkill of job.requiredSkills) {\r\n                    const requiredEmbedding = job.skillEmbeddings.get(requiredSkill);\r\n                    if (!requiredEmbedding) continue;\r\n\r\n                    const bestMatch = EmbeddingService.findBestSkillMatch(requiredEmbedding, candidate.skillEmbeddings);\r\n\r\n                    if (bestMatch) {\r\n                        // Similarity-based scoring with partial credit\r\n                        let creditPercentage = 0;\r\n                        let matchQuality = '';\r\n\r\n                        if (bestMatch.similarity >= 0.9) {\r\n                            creditPercentage = 1.0; // 100% credit - exact or very close match\r\n                            matchQuality = 'Excellent';\r\n                        } else if (bestMatch.similarity >= 0.7) {\r\n                            creditPercentage = 0.7; // 70% credit - related skill\r\n                            matchQuality = 'Good';\r\n                        } else if (bestMatch.similarity >= 0.5) {\r\n                            creditPercentage = 0.4; // 40% credit - somewhat related\r\n                            matchQuality = 'Partial';\r\n                        }\r\n\r\n                        if (creditPercentage > 0) {\r\n                            const pointsForThisSkill = (30 / job.requiredSkills.length) * creditPercentage;\r\n                            skillsScore += pointsForThisSkill;\r\n                            matchedSkills.push(bestMatch.skill);\r\n                            skillDetails.push(\r\n                                `${requiredSkill} ‚Üí ${bestMatch.skill} (${matchQuality} match: ${Math.round(bestMatch.similarity * 100)}%)`\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                score += skillsScore;\r\n                if (skillDetails.length > 0) {\r\n                    reasons.push(`Skills: ${skillDetails.join('; ')}`);\r\n                } else {\r\n                    reasons.push('Skills: No matching skills found');\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error('‚ö†Ô∏è Semantic skill matching failed, falling back to exact match:', error);\r\n                // Fallback to exact matching\r\n                const exactMatches = candidate.skills.filter((skill: string) =>\r\n                    job.requiredSkills.some((reqSkill: string) =>\r\n                        reqSkill.toLowerCase().includes(skill.toLowerCase()) ||\r\n                        skill.toLowerCase().includes(reqSkill.toLowerCase())\r\n                    )\r\n                );\r\n\r\n                if (exactMatches.length > 0) {\r\n                    skillsScore = (exactMatches.length / job.requiredSkills.length) * 30;\r\n                    score += skillsScore;\r\n                    reasons.push(`Skills (Exact): ${exactMatches.join(', ')}`);\r\n                    matchedSkills.push(...exactMatches);\r\n                }\r\n            }\r\n        } else {\r\n            score += 30;\r\n            reasons.push('Skills: Met (No specific skills required)');\r\n        }\r\n\r\n        // 3. License Match with Fuzzy Matching (20 points max - decreased from 25)\r\n        let licenseScore = 0;\r\n        const matchedLicenses: string[] = [];\r\n\r\n        if (job.requiredLicenses && job.requiredLicenses.length > 0) {\r\n            for (const requiredLicense of job.requiredLicenses) {\r\n                // Exact match or fuzzy match (e.g., \"PMP\" matches \"PMP certificate\")\r\n                const match = candidate.licenses.find((license: string) =>\r\n                    license.toLowerCase().includes(requiredLicense.toLowerCase()) ||\r\n                    requiredLicense.toLowerCase().includes(license.toLowerCase())\r\n                );\r\n\r\n                if (match) {\r\n                    matchedLicenses.push(match);\r\n                    licenseScore += (20 / job.requiredLicenses.length);\r\n                }\r\n            }\r\n\r\n            score += licenseScore;\r\n            if (matchedLicenses.length > 0) {\r\n                reasons.push(`Licenses: ${matchedLicenses.join(', ')}`);\r\n            } else {\r\n                reasons.push('Licenses: None matched');\r\n            }\r\n        } else {\r\n            score += 20;\r\n            reasons.push('Licenses: Met (None required)');\r\n        }\r\n\r\n        // 4. Overall Semantic Similarity (25 points max - decreased from 30)\r\n        try {\r\n            let jobEmbedding = job.embedding;\r\n            let candidateEmbedding = candidate.embedding;\r\n\r\n            // Generate embeddings if missing\r\n            if (!jobEmbedding) {\r\n                const jobText = EmbeddingService.prepareJobText(job);\r\n                jobEmbedding = await EmbeddingService.generateEmbedding(jobText);\r\n                job.embedding = jobEmbedding;\r\n            }\r\n\r\n            if (!candidateEmbedding) {\r\n                const candidateText = EmbeddingService.prepareCandidateText(candidate);\r\n                candidateEmbedding = await EmbeddingService.generateEmbedding(candidateText);\r\n                candidate.embedding = candidateEmbedding;\r\n            }\r\n\r\n            const similarity = EmbeddingService.calculateCosineSimilarity(jobEmbedding, candidateEmbedding);\r\n\r\n            // Convert similarity to score (0.5-1.0 range to 0-25 points)\r\n            let semanticScore = 0;\r\n            if (similarity > 0.5) {\r\n                semanticScore = ((similarity - 0.5) / 0.5) * 25;\r\n            }\r\n\r\n            score += semanticScore;\r\n\r\n            if (semanticScore > 5) {\r\n                reasons.push(`Overall Fit: ${Math.round(similarity * 100)}% match`);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('‚ö†Ô∏è Overall semantic matching failed:', error);\r\n        }\r\n\r\n        return {\r\n            score: Math.min(100, Math.round(score)),\r\n            reasons,\r\n            matchedSkills,\r\n            missingRequirements: this.findMissingRequirements(candidate, job)\r\n        };\r\n    }\r\n\r\n    static analyzeJobDescription(candidate: any, job: any) {\r\n        const jobText = `${job.title} ${job.description}`.toLowerCase();\r\n        const candidateText = candidate.rawText.toLowerCase();\r\n\r\n        const keywords = [\r\n            'project management', 'banking', 'credit card', 'fintech', 'it', 'software',\r\n            'development', 'database', 'cloud', 'leadership', 'management', 'strategy',\r\n            'planning', 'agile', 'scrum', 'api', 'integration', 'consulting',\r\n            'nursing', 'healthcare', 'patient care', 'clinical', 'emergency'\r\n        ];\r\n\r\n        const matchedKeywords: string[] = [];\r\n        let keywordMatches = 0;\r\n\r\n        for (const keyword of keywords) {\r\n            if (jobText.includes(keyword) && candidateText.includes(keyword)) {\r\n                matchedKeywords.push(keyword);\r\n                keywordMatches++;\r\n            }\r\n        }\r\n\r\n        for (const skill of candidate.skills) {\r\n            if (jobText.includes(skill.toLowerCase()) && !matchedKeywords.includes(skill.toLowerCase())) {\r\n                matchedKeywords.push(skill);\r\n                keywordMatches++;\r\n            }\r\n        }\r\n\r\n        const score = Math.min(30, keywordMatches * 6);\r\n\r\n        return {\r\n            score,\r\n            keywords: matchedKeywords.slice(0, 5)\r\n        };\r\n    }\r\n\r\n    static findMissingRequirements(candidate: any, job: any) {\r\n        const missing = [];\r\n\r\n        if (candidate.experience < (job.minExperience || 0)) {\r\n            missing.push(`Needs ${job.minExperience - candidate.experience} more years experience`);\r\n        }\r\n\r\n        const missingLicenses = job.requiredLicenses.filter((license: string) =>\r\n            !candidate.licenses.includes(license)\r\n        );\r\n\r\n        if (missingLicenses.length > 0) {\r\n            missing.push(`Missing licenses: ${missingLicenses.join(', ')}`);\r\n        }\r\n\r\n        return missing;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/app/api/results/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { readFile } from 'fs/promises';\r\nimport { MatchingEngine } from '../../../services/matchingService';\r\n\r\n\r\nexport async function GET(request: NextRequest) {\r\n    console.log('üîç RESULTS API CALLED - Fetching all candidates with matches...');\r\n\r\n    try {\r\n        const { searchParams } = new URL(request.url);\r\n        const jobId = searchParams.get('jobId');\r\n        const sortBy = searchParams.get('sortBy') || 'score';\r\n\r\n        // Read database\r\n        const dbData = await readFile('./uploads/database.json', 'utf-8');\r\n        const database = JSON.parse(dbData);\r\n\r\n        const candidates = database.candidates || [];\r\n        const jobs = database.jobs?.filter((job: any) => job.isActive !== false) || [];\r\n\r\n        if (candidates.length === 0 || jobs.length === 0) {\r\n            return NextResponse.json({\r\n                success: true,\r\n                candidates: [],\r\n                stats: {\r\n                    totalCVs: candidates.length,\r\n                    totalJobs: jobs.length,\r\n                    totalCandidates: 0\r\n                }\r\n            });\r\n        }\r\n\r\n        // Filter jobs if jobId is specified\r\n        const targetJobs = jobId\r\n            ? jobs.filter((job: any) => job.id === jobId)\r\n            : jobs;\r\n\r\n        // Process candidates - SHOW ALL MATCHES\r\n        const candidatesWithMatches = [];\r\n\r\n        for (const candidate of candidates) {\r\n            const allMatches = [];\r\n\r\n            for (const job of targetJobs) {\r\n                const matchResult = await MatchingEngine.calculateMatch(candidate, job);\r\n\r\n                // Include ALL matches, regardless of score\r\n                allMatches.push({\r\n                    jobId: job.id,\r\n                    jobTitle: job.title,\r\n                    department: job.department,\r\n                    location: job.location,\r\n                    score: matchResult.score,\r\n                    threshold: job.matchThreshold || 70,\r\n                    reasons: matchResult.reasons,\r\n                    matchedSkills: matchResult.matchedSkills\r\n                });\r\n            }\r\n\r\n            // Sort matches by score (highest first)\r\n            allMatches.sort((a, b) => b.score - a.score);\r\n\r\n            candidatesWithMatches.push({\r\n                id: candidate.id,\r\n                fileId: candidate.fileId,\r\n                name: candidate.name,\r\n                email: candidate.email,\r\n                phone: candidate.phone,\r\n                experience: candidate.experience,\r\n                skills: candidate.skills,\r\n                licenses: candidate.licenses,\r\n                location: candidate.location,\r\n                filePath: candidate.filePath,\r\n                matches: allMatches,\r\n                highestScore: allMatches.length > 0 ? allMatches[0].score : 0,\r\n                totalMatches: allMatches.length\r\n            });\r\n        }\r\n\r\n        // Sort results\r\n        switch (sortBy) {\r\n            case 'name':\r\n                candidatesWithMatches.sort((a: any, b: any) => a.name.localeCompare(b.name));\r\n                break;\r\n            case 'experience':\r\n                candidatesWithMatches.sort((a: any, b: any) => b.experience - a.experience);\r\n                break;\r\n            case 'score':\r\n            default:\r\n                candidatesWithMatches.sort((a: any, b: any) => b.highestScore - a.highestScore);\r\n                break;\r\n        }\r\n\r\n        const stats = {\r\n            totalCVs: candidates.length,\r\n            totalJobs: targetJobs.length,\r\n            totalCandidates: candidatesWithMatches.length,\r\n            matchRate: Math.round((candidatesWithMatches.length / candidates.length) * 100)\r\n        };\r\n\r\n        console.log(`‚úÖ Results fetched:`, stats);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            candidates: candidatesWithMatches,\r\n            stats,\r\n            filters: {\r\n                jobId,\r\n                sortBy\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Results API error:', error);\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: 'Failed to fetch results',\r\n                details: error instanceof Error ? error.message : 'Unknown error'\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,eAAe,IAAI,OAAoB;IAC1C,QAAQ,GAAG,CAAC;IAEZ,IAAI;QACA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,SAAS,aAAa,GAAG,CAAC,aAAa;QAE7C,gBAAgB;QAChB,MAAM,SAAS,MAAM,IAAA,iIAAQ,EAAC,2BAA2B;QACzD,MAAM,WAAW,KAAK,KAAK,CAAC;QAE5B,MAAM,aAAa,SAAS,UAAU,IAAI,EAAE;QAC5C,MAAM,OAAO,SAAS,IAAI,EAAE,OAAO,CAAC,MAAa,IAAI,QAAQ,KAAK,UAAU,EAAE;QAE9E,IAAI,WAAW,MAAM,KAAK,KAAK,KAAK,MAAM,KAAK,GAAG;YAC9C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT,YAAY,EAAE;gBACd,OAAO;oBACH,UAAU,WAAW,MAAM;oBAC3B,WAAW,KAAK,MAAM;oBACtB,iBAAiB;gBACrB;YACJ;QACJ;QAEA,oCAAoC;QACpC,MAAM,aAAa,QACb,KAAK,MAAM,CAAC,CAAC,MAAa,IAAI,EAAE,KAAK,SACrC;QAEN,wCAAwC;QACxC,MAAM,wBAAwB,EAAE;QAEhC,KAAK,MAAM,aAAa,WAAY;YAChC,MAAM,aAAa,EAAE;YAErB,KAAK,MAAM,OAAO,WAAY;gBAC1B,MAAM,cAAc,MAAM,sJAAc,CAAC,cAAc,CAAC,WAAW;gBAEnE,2CAA2C;gBAC3C,WAAW,IAAI,CAAC;oBACZ,OAAO,IAAI,EAAE;oBACb,UAAU,IAAI,KAAK;oBACnB,YAAY,IAAI,UAAU;oBAC1B,UAAU,IAAI,QAAQ;oBACtB,OAAO,YAAY,KAAK;oBACxB,WAAW,IAAI,cAAc,IAAI;oBACjC,SAAS,YAAY,OAAO;oBAC5B,eAAe,YAAY,aAAa;gBAC5C;YACJ;YAEA,wCAAwC;YACxC,WAAW,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK;YAE3C,sBAAsB,IAAI,CAAC;gBACvB,IAAI,UAAU,EAAE;gBAChB,QAAQ,UAAU,MAAM;gBACxB,MAAM,UAAU,IAAI;gBACpB,OAAO,UAAU,KAAK;gBACtB,OAAO,UAAU,KAAK;gBACtB,YAAY,UAAU,UAAU;gBAChC,QAAQ,UAAU,MAAM;gBACxB,UAAU,UAAU,QAAQ;gBAC5B,UAAU,UAAU,QAAQ;gBAC5B,UAAU,UAAU,QAAQ;gBAC5B,SAAS;gBACT,cAAc,WAAW,MAAM,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG;gBAC5D,cAAc,WAAW,MAAM;YACnC;QACJ;QAEA,eAAe;QACf,OAAQ;YACJ,KAAK;gBACD,sBAAsB,IAAI,CAAC,CAAC,GAAQ,IAAW,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;gBAC1E;YACJ,KAAK;gBACD,sBAAsB,IAAI,CAAC,CAAC,GAAQ,IAAW,EAAE,UAAU,GAAG,EAAE,UAAU;gBAC1E;YACJ,KAAK;YACL;gBACI,sBAAsB,IAAI,CAAC,CAAC,GAAQ,IAAW,EAAE,YAAY,GAAG,EAAE,YAAY;gBAC9E;QACR;QAEA,MAAM,QAAQ;YACV,UAAU,WAAW,MAAM;YAC3B,WAAW,WAAW,MAAM;YAC5B,iBAAiB,sBAAsB,MAAM;YAC7C,WAAW,KAAK,KAAK,CAAC,AAAC,sBAAsB,MAAM,GAAG,WAAW,MAAM,GAAI;QAC/E;QAEA,QAAQ,GAAG,CAAC,CAAC,kBAAkB,CAAC,EAAE;QAElC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,YAAY;YACZ;YACA,SAAS;gBACL;gBACA;YACJ;QACJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACtD,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}