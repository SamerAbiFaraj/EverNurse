{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/services/embeddingService.ts"],"sourcesContent":["import OpenAI from 'openai';\r\n\r\n// Initialize OpenAI client\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport class EmbeddingService {\r\n    /**\r\n     * Generate embedding vector for text using OpenAI's text-embedding-3-small model\r\n     */\r\n    static async generateEmbedding(text: string): Promise<number[]> {\r\n        try {\r\n            console.log('üß† Generating embedding for text (length:', text.length, 'chars)');\r\n\r\n            // Truncate text if too long (max ~8000 tokens ‚âà 32000 chars)\r\n            const truncatedText = text.substring(0, 32000);\r\n\r\n            const response = await openai.embeddings.create({\r\n                model: 'text-embedding-3-small',\r\n                input: truncatedText,\r\n            });\r\n\r\n            const embedding = response.data[0].embedding;\r\n            console.log('‚úÖ Embedding generated (dimensions:', embedding.length, ')');\r\n\r\n            return embedding;\r\n        } catch (error) {\r\n            console.error('‚ùå Embedding generation failed:', error);\r\n            throw new Error(`Failed to generate embedding: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate cosine similarity between two embedding vectors\r\n     * Returns a value between -1 and 1, where 1 means identical, 0 means orthogonal, -1 means opposite\r\n     */\r\n    static calculateCosineSimilarity(vec1: number[], vec2: number[]): number {\r\n        if (vec1.length !== vec2.length) {\r\n            throw new Error('Vectors must have the same dimensions');\r\n        }\r\n\r\n        let dotProduct = 0;\r\n        let norm1 = 0;\r\n        let norm2 = 0;\r\n\r\n        for (let i = 0; i < vec1.length; i++) {\r\n            dotProduct += vec1[i] * vec2[i];\r\n            norm1 += vec1[i] * vec1[i];\r\n            norm2 += vec2[i] * vec2[i];\r\n        }\r\n\r\n        const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n\r\n        if (magnitude === 0) {\r\n            return 0;\r\n        }\r\n\r\n        const similarity = dotProduct / magnitude;\r\n\r\n        console.log('üìä Cosine similarity:', similarity.toFixed(4));\r\n\r\n        return similarity;\r\n    }\r\n\r\n    /**\r\n     * Prepare text for embedding generation by combining relevant fields\r\n     */\r\n    static prepareJobText(job: any): string {\r\n        const parts = [\r\n            job.title || '',\r\n            job.description || '',\r\n            job.department || '',\r\n            job.location || '',\r\n            (job.requiredSkills || []).join(', '),\r\n            (job.requiredLicenses || []).join(', '),\r\n            job.requirements ? (Array.isArray(job.requirements) ? job.requirements.join(', ') : job.requirements) : ''\r\n        ];\r\n\r\n        return parts.filter(p => p).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Prepare candidate text for embedding generation\r\n     */\r\n    static prepareCandidateText(candidate: any): string {\r\n        const parts = [\r\n            candidate.name || '',\r\n            `${candidate.experience || 0} years of experience`,\r\n            (candidate.skills || []).join(', '),\r\n            (candidate.licenses || []).join(', '),\r\n            candidate.location || '',\r\n            candidate.rawText || ''\r\n        ];\r\n\r\n        return parts.filter(p => p).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Generate embeddings for multiple texts in a single batch request\r\n     * More efficient than individual requests\r\n     */\r\n    static async generateBatchEmbeddings(texts: string[]): Promise<number[][]> {\r\n        try {\r\n            if (texts.length === 0) return [];\r\n\r\n            console.log(`üß† Generating ${texts.length} embeddings in batch...`);\r\n\r\n            // Truncate each text if too long\r\n            const truncatedTexts = texts.map(text => text.substring(0, 32000));\r\n\r\n            const response = await openai.embeddings.create({\r\n                model: 'text-embedding-3-small',\r\n                input: truncatedTexts,\r\n            });\r\n\r\n            const embeddings = response.data.map(item => item.embedding);\r\n            console.log(`‚úÖ Generated ${embeddings.length} embeddings`);\r\n\r\n            return embeddings;\r\n        } catch (error) {\r\n            console.error('‚ùå Batch embedding generation failed:', error);\r\n            throw new Error(`Failed to generate batch embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate embeddings for individual skills/requirements\r\n     * Returns a map of skill -> embedding\r\n     */\r\n    static async generateSkillEmbeddings(skills: string[]): Promise<Map<string, number[]>> {\r\n        if (skills.length === 0) return new Map();\r\n\r\n        const embeddings = await this.generateBatchEmbeddings(skills);\r\n        const skillEmbeddingMap = new Map<string, number[]>();\r\n\r\n        skills.forEach((skill, index) => {\r\n            skillEmbeddingMap.set(skill, embeddings[index]);\r\n        });\r\n\r\n        return skillEmbeddingMap;\r\n    }\r\n\r\n    /**\r\n     * Calculate semantic similarity between a candidate skill and a required skill\r\n     * Returns a similarity score between 0 and 1\r\n     */\r\n    static calculateSkillSimilarity(\r\n        candidateSkillEmbedding: number[],\r\n        requiredSkillEmbedding: number[]\r\n    ): number {\r\n        const similarity = this.calculateCosineSimilarity(candidateSkillEmbedding, requiredSkillEmbedding);\r\n        // Normalize to 0-1 range (cosine similarity is -1 to 1)\r\n        return Math.max(0, similarity);\r\n    }\r\n\r\n    /**\r\n     * Find the best matching candidate skill for a required skill\r\n     * Returns the best match with its similarity score\r\n     */\r\n    static findBestSkillMatch(\r\n        requiredSkillEmbedding: number[],\r\n        candidateSkillEmbeddings: Map<string, number[]>\r\n    ): { skill: string; similarity: number } | null {\r\n        let bestMatch: { skill: string; similarity: number } | null = null;\r\n\r\n        for (const [skill, embedding] of candidateSkillEmbeddings.entries()) {\r\n            const similarity = this.calculateSkillSimilarity(embedding, requiredSkillEmbedding);\r\n\r\n            if (!bestMatch || similarity > bestMatch.similarity) {\r\n                bestMatch = { skill, similarity };\r\n            }\r\n        }\r\n\r\n        return bestMatch;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,2BAA2B;AAC3B,MAAM,SAAS,IAAI,mLAAM,CAAC;IACtB,QAAQ,QAAQ,GAAG,CAAC,cAAc;AACtC;AAEO,MAAM;IACT;;KAEC,GACD,aAAa,kBAAkB,IAAY,EAAqB;QAC5D,IAAI;YACA,QAAQ,GAAG,CAAC,6CAA6C,KAAK,MAAM,EAAE;YAEtE,6DAA6D;YAC7D,MAAM,gBAAgB,KAAK,SAAS,CAAC,GAAG;YAExC,MAAM,WAAW,MAAM,OAAO,UAAU,CAAC,MAAM,CAAC;gBAC5C,OAAO;gBACP,OAAO;YACX;YAEA,MAAM,YAAY,SAAS,IAAI,CAAC,EAAE,CAAC,SAAS;YAC5C,QAAQ,GAAG,CAAC,sCAAsC,UAAU,MAAM,EAAE;YAEpE,OAAO;QACX,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,iBAAiB;QAC/G;IACJ;IAEA;;;KAGC,GACD,OAAO,0BAA0B,IAAc,EAAE,IAAc,EAAU;QACrE,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,EAAE;YAC7B,MAAM,IAAI,MAAM;QACpB;QAEA,IAAI,aAAa;QACjB,IAAI,QAAQ;QACZ,IAAI,QAAQ;QAEZ,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,cAAc,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;YAC/B,SAAS,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;YAC1B,SAAS,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;QAC9B;QAEA,MAAM,YAAY,KAAK,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC;QAE/C,IAAI,cAAc,GAAG;YACjB,OAAO;QACX;QAEA,MAAM,aAAa,aAAa;QAEhC,QAAQ,GAAG,CAAC,yBAAyB,WAAW,OAAO,CAAC;QAExD,OAAO;IACX;IAEA;;KAEC,GACD,OAAO,eAAe,GAAQ,EAAU;QACpC,MAAM,QAAQ;YACV,IAAI,KAAK,IAAI;YACb,IAAI,WAAW,IAAI;YACnB,IAAI,UAAU,IAAI;YAClB,IAAI,QAAQ,IAAI;YAChB,CAAC,IAAI,cAAc,IAAI,EAAE,EAAE,IAAI,CAAC;YAChC,CAAC,IAAI,gBAAgB,IAAI,EAAE,EAAE,IAAI,CAAC;YAClC,IAAI,YAAY,GAAI,MAAM,OAAO,CAAC,IAAI,YAAY,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC,QAAQ,IAAI,YAAY,GAAI;SAC3G;QAED,OAAO,MAAM,MAAM,CAAC,CAAA,IAAK,GAAG,IAAI,CAAC;IACrC;IAEA;;KAEC,GACD,OAAO,qBAAqB,SAAc,EAAU;QAChD,MAAM,QAAQ;YACV,UAAU,IAAI,IAAI;YAClB,GAAG,UAAU,UAAU,IAAI,EAAE,oBAAoB,CAAC;YAClD,CAAC,UAAU,MAAM,IAAI,EAAE,EAAE,IAAI,CAAC;YAC9B,CAAC,UAAU,QAAQ,IAAI,EAAE,EAAE,IAAI,CAAC;YAChC,UAAU,QAAQ,IAAI;YACtB,UAAU,OAAO,IAAI;SACxB;QAED,OAAO,MAAM,MAAM,CAAC,CAAA,IAAK,GAAG,IAAI,CAAC;IACrC;IAEA;;;KAGC,GACD,aAAa,wBAAwB,KAAe,EAAuB;QACvE,IAAI;YACA,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO,EAAE;YAEjC,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,MAAM,MAAM,CAAC,uBAAuB,CAAC;YAElE,iCAAiC;YACjC,MAAM,iBAAiB,MAAM,GAAG,CAAC,CAAA,OAAQ,KAAK,SAAS,CAAC,GAAG;YAE3D,MAAM,WAAW,MAAM,OAAO,UAAU,CAAC,MAAM,CAAC;gBAC5C,OAAO;gBACP,OAAO;YACX;YAEA,MAAM,aAAa,SAAS,IAAI,CAAC,GAAG,CAAC,CAAA,OAAQ,KAAK,SAAS;YAC3D,QAAQ,GAAG,CAAC,CAAC,YAAY,EAAE,WAAW,MAAM,CAAC,WAAW,CAAC;YAEzD,OAAO;QACX,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,wCAAwC;YACtD,MAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,iBAAiB;QACtH;IACJ;IAEA;;;KAGC,GACD,aAAa,wBAAwB,MAAgB,EAAkC;QACnF,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,IAAI;QAEpC,MAAM,aAAa,MAAM,IAAI,CAAC,uBAAuB,CAAC;QACtD,MAAM,oBAAoB,IAAI;QAE9B,OAAO,OAAO,CAAC,CAAC,OAAO;YACnB,kBAAkB,GAAG,CAAC,OAAO,UAAU,CAAC,MAAM;QAClD;QAEA,OAAO;IACX;IAEA;;;KAGC,GACD,OAAO,yBACH,uBAAiC,EACjC,sBAAgC,EAC1B;QACN,MAAM,aAAa,IAAI,CAAC,yBAAyB,CAAC,yBAAyB;QAC3E,wDAAwD;QACxD,OAAO,KAAK,GAAG,CAAC,GAAG;IACvB;IAEA;;;KAGC,GACD,OAAO,mBACH,sBAAgC,EAChC,wBAA+C,EACH;QAC5C,IAAI,YAA0D;QAE9D,KAAK,MAAM,CAAC,OAAO,UAAU,IAAI,yBAAyB,OAAO,GAAI;YACjE,MAAM,aAAa,IAAI,CAAC,wBAAwB,CAAC,WAAW;YAE5D,IAAI,CAAC,aAAa,aAAa,UAAU,UAAU,EAAE;gBACjD,YAAY;oBAAE;oBAAO;gBAAW;YACpC;QACJ;QAEA,OAAO;IACX;AACJ"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/app/api/jobs/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { existsSync } from 'fs';\r\nimport { EmbeddingService } from '../../../services/embeddingService';\r\n\r\n// Database file path\r\nconst DB_PATH = './uploads/database.json';\r\n\r\n// Initialize database if it doesn't exist\r\nasync function initDatabase() {\r\n    if (!existsSync(DB_PATH)) {\r\n        const initialDb = {\r\n            candidates: [],\r\n            matches: [],\r\n            jobs: []\r\n        };\r\n        await writeFile(DB_PATH, JSON.stringify(initialDb, null, 2));\r\n        return initialDb;\r\n    }\r\n    const data = await readFile(DB_PATH, 'utf-8');\r\n    return JSON.parse(data);\r\n}\r\n\r\n// GET /api/jobs - List all jobs\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        const db = await initDatabase();\r\n\r\n        // Get query params\r\n        const { searchParams } = new URL(request.url);\r\n        const activeOnly = searchParams.get('active') === 'true';\r\n\r\n        let jobs = db.jobs || [];\r\n\r\n        // Filter active jobs if requested\r\n        if (activeOnly) {\r\n            jobs = jobs.filter((job: any) => job.isActive !== false);\r\n        }\r\n\r\n        // Sort by creation date (newest first)\r\n        jobs.sort((a: any, b: any) => {\r\n            const dateA = new Date(a.createdAt || 0).getTime();\r\n            const dateB = new Date(b.createdAt || 0).getTime();\r\n            return dateB - dateA;\r\n        });\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            jobs,\r\n            count: jobs.length\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Error fetching jobs:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to fetch jobs' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\n// POST /api/jobs - Create new job\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n\r\n        // Validate required fields\r\n        const requiredFields = ['title', 'department', 'location', 'description'];\r\n        for (const field of requiredFields) {\r\n            if (!body[field]) {\r\n                return NextResponse.json(\r\n                    { error: `Missing required field: ${field}` },\r\n                    { status: 400 }\r\n                );\r\n            }\r\n        }\r\n\r\n        // Read database\r\n        const db = await initDatabase();\r\n        if (!db.jobs) db.jobs = [];\r\n\r\n        // Parse requirements array into structured fields\r\n        const requirements = body.requirements || [];\r\n        const requiredSkills: string[] = [];\r\n        const requiredLicenses: string[] = [];\r\n        let minExperience = 0;\r\n\r\n        // Common license keywords\r\n        const licenseKeywords = ['DHA', 'DOH', 'MOH', 'BLS', 'ACLS', 'PALS', 'NRP', 'RN', 'LPN', 'CNA', 'PMP', 'PCI-DSS'];\r\n\r\n        // Parse each requirement\r\n        for (const req of requirements) {\r\n            const reqLower = req.toLowerCase().trim();\r\n\r\n            // Check for experience (e.g., \"3+ years\", \"5 years experience\")\r\n            const expMatch = reqLower.match(/(\\d+)\\+?\\s*(years?|yrs?)/);\r\n            if (expMatch) {\r\n                const years = parseInt(expMatch[1]);\r\n                if (years > minExperience) {\r\n                    minExperience = years;\r\n                }\r\n                continue; // Don't add to skills\r\n            }\r\n\r\n            // Check if it's a license\r\n            const isLicense = licenseKeywords.some(keyword =>\r\n                req.toUpperCase().includes(keyword.toUpperCase())\r\n            );\r\n\r\n            if (isLicense) {\r\n                requiredLicenses.push(req.trim());\r\n            } else {\r\n                // It's a skill\r\n                requiredSkills.push(req.trim());\r\n            }\r\n        }\r\n\r\n        // Create new job\r\n        const newJob: any = {\r\n            id: `job-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n            title: body.title,\r\n            department: body.department,\r\n            location: body.location,\r\n            description: body.description,\r\n            requirements: body.requirements || [],\r\n            requiredSkills: requiredSkills,\r\n            preferredSkills: body.preferredSkills || [],\r\n            requiredLicenses: requiredLicenses,\r\n            minExperience: minExperience,\r\n            matchThreshold: body.matchThreshold || 70,\r\n            isActive: body.isActive !== undefined ? body.isActive : true,\r\n            salaryRange: body.salaryRange || null,\r\n            benefits: body.benefits || [],\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString()\r\n        };\r\n\r\n        // Generate embedding for the new job\r\n        try {\r\n            const jobText = EmbeddingService.prepareJobText(newJob);\r\n            newJob.embedding = await EmbeddingService.generateEmbedding(jobText);\r\n            newJob.embeddingGeneratedAt = new Date().toISOString();\r\n        } catch (error) {\r\n            console.error('‚ö†Ô∏è Failed to generate embedding for new job:', error);\r\n            // Continue without embedding - it will be generated on demand during matching\r\n        }\r\n\r\n        // Add to database\r\n        db.jobs.push(newJob);\r\n\r\n        // Save database\r\n        await writeFile(DB_PATH, JSON.stringify(db, null, 2));\r\n\r\n        console.log(`‚úÖ Created job: ${newJob.title} (${newJob.id})`);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            job: newJob,\r\n            message: 'Job created successfully'\r\n        }, { status: 201 });\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Error creating job:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to create job' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\n// PUT /api/jobs - Update existing job\r\nexport async function PUT(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n\r\n        if (!body.id) {\r\n            return NextResponse.json(\r\n                { error: 'Job ID is required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Read database\r\n        const db = await initDatabase();\r\n\r\n        // Find job index\r\n        const jobIndex = db.jobs.findIndex((j: any) => j.id === body.id);\r\n\r\n        if (jobIndex === -1) {\r\n            return NextResponse.json(\r\n                { error: 'Job not found' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Parse requirements array into structured fields if provided\r\n        let parsedFields: any = {};\r\n        if (body.requirements) {\r\n            const requirements = body.requirements;\r\n            const requiredSkills: string[] = [];\r\n            const requiredLicenses: string[] = [];\r\n            let minExperience = 0;\r\n\r\n            // Common license keywords\r\n            const licenseKeywords = ['DHA', 'DOH', 'MOH', 'BLS', 'ACLS', 'PALS', 'NRP', 'RN', 'LPN', 'CNA', 'PMP', 'PCI-DSS'];\r\n\r\n            // Parse each requirement\r\n            for (const req of requirements) {\r\n                const reqLower = req.toLowerCase().trim();\r\n\r\n                // Check for experience\r\n                const expMatch = reqLower.match(/(\\d+)\\+?\\s*(years?|yrs?)/);\r\n                if (expMatch) {\r\n                    const years = parseInt(expMatch[1]);\r\n                    if (years > minExperience) {\r\n                        minExperience = years;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                // Check if it's a license\r\n                const isLicense = licenseKeywords.some(keyword =>\r\n                    req.toUpperCase().includes(keyword.toUpperCase())\r\n                );\r\n\r\n                if (isLicense) {\r\n                    requiredLicenses.push(req.trim());\r\n                } else {\r\n                    requiredSkills.push(req.trim());\r\n                }\r\n            }\r\n\r\n            parsedFields = {\r\n                requirements: requirements,\r\n                requiredSkills: requiredSkills,\r\n                requiredLicenses: requiredLicenses,\r\n                minExperience: minExperience\r\n            };\r\n        }\r\n\r\n        // Update job\r\n        const updatedJob = {\r\n            ...db.jobs[jobIndex],\r\n            ...body,\r\n            ...parsedFields,\r\n            updatedAt: new Date().toISOString()\r\n        };\r\n\r\n        // Regenerate embedding if critical fields changed\r\n        // (Simplified: just regenerate if description or title changes)\r\n        if (body.description !== db.jobs[jobIndex].description ||\r\n            body.title !== db.jobs[jobIndex].title) {\r\n            try {\r\n                const jobText = EmbeddingService.prepareJobText(updatedJob);\r\n                updatedJob.embedding = await EmbeddingService.generateEmbedding(jobText);\r\n                updatedJob.embeddingGeneratedAt = new Date().toISOString();\r\n            } catch (error) {\r\n                console.error('‚ö†Ô∏è Failed to regenerate embedding for updated job:', error);\r\n            }\r\n        }\r\n\r\n        db.jobs[jobIndex] = updatedJob;\r\n\r\n        // Save database\r\n        await writeFile(DB_PATH, JSON.stringify(db, null, 2));\r\n\r\n        console.log(`‚úÖ Updated job: ${updatedJob.title} (${updatedJob.id})`);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            job: updatedJob,\r\n            message: 'Job updated successfully'\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Error updating job:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to update job' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}