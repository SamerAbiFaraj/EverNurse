{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/EverNurse-Project/evernurse-cv-matcher/src/app/api/parse/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { readFile } from 'fs/promises';\r\nimport { join } from 'path';\r\n\r\n// Import mammoth with named import\r\nimport { extractRawText } from 'mammoth';\r\n\r\nclass RealParser {\r\n    static async parsePDF(buffer: Buffer): Promise<string> {\r\n        try {\r\n            console.log('üìÑ Starting PDF parsing...');\r\n            console.log('üìä Buffer size:', buffer.length, 'bytes');\r\n\r\n            // Use a more reliable PDF parsing approach\r\n            let pdfText = '';\r\n\r\n            try {\r\n                // Approach 1: Try pdf-parse-fixed\r\n                const pdfParse = (await import('pdf-parse-fixed')).default;\r\n                console.log('‚úÖ Using pdf-parse-fixed');\r\n                const data = await pdfParse(buffer);\r\n                pdfText = data.text;\r\n            } catch (error1) {\r\n                console.log('‚ùå pdf-parse-fixed failed, trying alternative...');\r\n\r\n                // Approach 2: Try the original pdf-parse with different import\r\n                try {\r\n                    // Use dynamic import to avoid build issues\r\n                    const pdfModule = await import('pdf-parse-fixed');\r\n                    const pdfParse = pdfModule.default || pdfModule;\r\n                    console.log('‚úÖ Using pdf-parse with dynamic import');\r\n                    const data = await pdfParse(buffer);\r\n                    pdfText = data.text;\r\n                } catch (error2) {\r\n                    console.log('‚ùå All PDF parsing failed, using fallback');\r\n                    throw new Error('All PDF parsing methods failed');\r\n                }\r\n            }\r\n\r\n            console.log('‚úÖ PDF parsing completed');\r\n            console.log('üìù Extracted text length:', pdfText.length);\r\n\r\n            if (pdfText.length < 10) {\r\n                console.log('‚ö†Ô∏è Very little text extracted from PDF');\r\n            }\r\n\r\n            return pdfText;\r\n        } catch (error) {\r\n            console.error('‚ùå PDF parsing failed with error:', error);\r\n            throw new Error(`Failed to parse PDF file: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    static async parseDOCX(buffer: Buffer): Promise<string> {\r\n        try {\r\n            console.log('üìÑ Parsing DOCX file...');\r\n            const result = await extractRawText({ buffer });\r\n            console.log('‚úÖ DOCX parsed successfully, text length:', result.value.length);\r\n            return result.value;\r\n        } catch (error) {\r\n            console.error('‚ùå DOCX parsing failed:', error);\r\n            throw new Error('Failed to parse DOCX file');\r\n        }\r\n    }\r\n\r\n    static extractCandidateData(text: string, originalFilename?: string) {\r\n        console.log('üîç Extracting candidate data from text...');\r\n\r\n        // If text extraction failed completely, use filename as fallback\r\n        if (!text || text.length < 10) {\r\n            console.log('‚ö†Ô∏è Text extraction failed, using filename fallback');\r\n            return this.extractFromFilename(originalFilename);\r\n        }\r\n\r\n        console.log('üìù Text sample (first 500 chars):', text.substring(0, 500));\r\n\r\n        // Convert text to lowercase for easier matching\r\n        const lowerText = text.toLowerCase();\r\n\r\n        // Extract name - IMPROVED LOGIC\r\n        let name = this.extractName(text, originalFilename);\r\n        console.log('‚úÖ Name extracted:', name);\r\n\r\n        // Extract email\r\n        const emailMatch = text.match(/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/);\r\n        const email = emailMatch ? emailMatch[0] : '';\r\n        if (email) console.log('‚úÖ Email extracted:', email);\r\n\r\n        // Extract phone (UAE format)\r\n        const phoneMatch = text.match(/(?:\\+?971)?[-\\s]?\\(?\\d{1,4}\\)?[-\\s]?\\d{1,4}[-\\s]?\\d{1,9}/);\r\n        const phone = phoneMatch ? phoneMatch[0] : '';\r\n        if (phone) console.log('‚úÖ Phone extracted:', phone);\r\n\r\n        // Extract experience (look for years) - IMPROVED REGEX\r\n        let experience = 0;\r\n        // Try multiple patterns to catch \"17 years' experience\" and variations\r\n        const textSample = text.substring(0, 1000); // Check first 1000 chars\r\n        const patterns = [\r\n            /(\\d+)\\s+years?['\\u2019\\u0027]?\\s*(?:of\\s+)?experience/gi,\r\n            /(?:with|have)\\s+(\\d+)\\s+years/gi,\r\n            /experience[:\\s]+(\\d+)\\s+years/gi\r\n        ];\r\n\r\n        for (const pattern of patterns) {\r\n            const matches = [...textSample.matchAll(pattern)];\r\n            if (matches.length > 0) {\r\n                experience = parseInt(matches[0][1]) || 0;\r\n                console.log('‚úÖ Experience extracted:', experience, 'years from pattern:', pattern);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (experience === 0) {\r\n            console.log('‚ö†Ô∏è No experience pattern matched in text');\r\n        }\r\n\r\n        // Extract skills (EXPANDED LIST)\r\n        const commonSkills = [\r\n            // Nursing/Healthcare\r\n            'ACLS', 'BLS', 'PALS', 'ICU', 'ER', 'Emergency', 'Critical Care', 'Pediatrics',\r\n            'Geriatrics', 'Medication', 'Assessment', 'Patient Care', 'Ventilator',\r\n            'Trauma', 'Surgical', 'Recovery', 'Nursing', 'Healthcare', 'Clinical',\r\n            'Telemetry', 'Cardiac', 'Oncology', 'Orthopedics', 'Psychiatric', 'Mental Health',\r\n            // IT/Tech\r\n            'Project Management', 'IT', 'Software', 'Development', 'Database', 'SQL', 'Cloud',\r\n            'AWS', 'Azure', 'FinTech', 'Banking', 'Credit Card', 'Payment', 'Digital',\r\n            'Transformation', 'Agile', 'Scrum', 'Waterfall', 'API', 'Integration',\r\n            // Business/Management\r\n            'Leadership', 'Management', 'Strategy', 'Planning', 'Budgeting', 'Stakeholder',\r\n            'Business Analysis', 'Operations', 'Consulting', 'Team Building'\r\n        ];\r\n\r\n        const foundSkills = commonSkills.filter(skill =>\r\n            lowerText.includes(skill.toLowerCase())\r\n        );\r\n        console.log('‚úÖ Skills found:', foundSkills);\r\n\r\n        // Extract licenses (UAE healthcare licenses + professional certs)\r\n        const licenses = ['DHA', 'DOH', 'MOH', 'HAAD', 'PMP', 'PCI-DSS', 'AWS'];\r\n        const foundLicenses = licenses.filter(license =>\r\n            text.toUpperCase().includes(license)\r\n        );\r\n        console.log('‚úÖ Licenses found:', foundLicenses);\r\n\r\n        // Extract location (UAE locations + Lebanon)\r\n        const locations = ['Dubai', 'Abu Dhabi', 'Sharjah', 'Ajman', 'Ras Al Khaimah', 'Fujairah', 'Al Ain', 'Lebanon', 'Beirut'];\r\n        let location = '';\r\n        for (const loc of locations) {\r\n            if (text.includes(loc)) {\r\n                location = loc;\r\n                break;\r\n            }\r\n        }\r\n        if (location) console.log('‚úÖ Location found:', location);\r\n\r\n        console.log('‚úÖ Final extracted data:', {\r\n            name,\r\n            experience,\r\n            skills: foundSkills,\r\n            licenses: foundLicenses,\r\n            location\r\n        });\r\n\r\n        return {\r\n            name,\r\n            email,\r\n            phone,\r\n            experience,\r\n            skills: foundSkills,\r\n            licenses: foundLicenses,\r\n            location: location || 'UAE',\r\n            rawText: text.substring(0, 1000) // Store first 1000 chars for reference\r\n        };\r\n    }\r\n\r\n    // NEW: Improved name extraction method\r\n    static extractName(text: string, filename?: string): string {\r\n        console.log('üîç Extracting name from text...');\r\n\r\n        // Strategy 1: Look for name patterns in the first few lines\r\n        const lines = text.split('\\n').slice(0, 10); // Check first 10 lines\r\n        let name = '';\r\n\r\n        for (const line of lines) {\r\n            const trimmedLine = line.trim();\r\n\r\n            // Skip empty lines and obvious non-name lines\r\n            if (!trimmedLine ||\r\n                trimmedLine.length > 50 ||\r\n                trimmedLine.includes('@') || // Email\r\n                trimmedLine.match(/\\d/) || // Contains numbers\r\n                trimmedLine.toLowerCase().includes('curriculum') ||\r\n                trimmedLine.toLowerCase().includes('vitae') ||\r\n                trimmedLine.toLowerCase().includes('resume') ||\r\n                trimmedLine.toLowerCase().includes('address') ||\r\n                trimmedLine.toLowerCase().includes('phone') ||\r\n                trimmedLine.toLowerCase().includes('mobile')) {\r\n                continue;\r\n            }\r\n\r\n            // Look for proper name patterns (2-4 words, capitalized)\r\n            const words = trimmedLine.split(/\\s+/);\r\n            if (words.length >= 2 && words.length <= 4) {\r\n                // Check if most words start with capital letters (proper name)\r\n                const capitalizedWords = words.filter(word =>\r\n                    word.length > 1 && word[0] === word[0].toUpperCase() && !word.match(/^\\d/)\r\n                );\r\n\r\n                if (capitalizedWords.length >= 2) {\r\n                    // This looks like a name!\r\n                    name = trimmedLine;\r\n                    console.log('‚úÖ Found name in text:', name);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Strategy 2: If no name found in text, try filename\r\n        if (!name && filename) {\r\n            name = this.extractFromFilename(filename).name;\r\n            console.log('‚úÖ Using name from filename:', name);\r\n        }\r\n\r\n        // Strategy 3: Look for explicit name labels\r\n        if (!name) {\r\n            const namePatterns = [\r\n                /(?:name|full name)[:\\s]*([a-zA-Z\\s]{2,50})(?:\\n|$)/i,\r\n                /(?:candidate|applicant)[:\\s]*([a-zA-Z\\s]{2,50})(?:\\n|$)/i,\r\n                /^([A-Z][a-z]+ [A-Z][a-z]+ [A-Z][a-z]+)$/m, // Three capitalized words\r\n                /^([A-Z][a-z]+ [A-Z][a-z]+)$/m, // Two capitalized words\r\n            ];\r\n\r\n            for (const pattern of namePatterns) {\r\n                const match = text.match(pattern);\r\n                if (match && match[1]) {\r\n                    name = match[1].trim();\r\n                    console.log('‚úÖ Found name with pattern:', name);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Final fallback\r\n        if (!name) {\r\n            name = 'Unknown Candidate';\r\n            console.log('‚ö†Ô∏è Could not extract name, using fallback');\r\n        }\r\n\r\n        // Clean up the name\r\n        name = name.split(' ')\r\n            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\r\n            .join(' ')\r\n            .replace(/\\s+/g, ' ')\r\n            .trim();\r\n\r\n        return name;\r\n    }\r\n\r\n    // NEW: Separate method for filename extraction\r\n    static extractFromFilename(filename?: string) {\r\n        let name = 'Unknown Candidate';\r\n\r\n        if (filename) {\r\n            // Extract name from filename (remove extension and special chars)\r\n            name = filename\r\n                .replace(/\\.(pdf|docx?)$/i, '')\r\n                .replace(/[^a-zA-Z\\s]/g, ' ')\r\n                .replace(/\\s+/g, ' ')\r\n                .trim();\r\n\r\n            // Capitalize properly\r\n            name = name.split(' ').map(word =>\r\n                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n            ).join(' ');\r\n        }\r\n\r\n        // Mock some data based on common patterns\r\n        const experience = name.includes('Senior') ? 8 :\r\n            name.includes('Junior') ? 2 : 5;\r\n\r\n        const skills = ['Patient Care', 'Nursing', 'Healthcare'];\r\n        const licenses = ['DHA']; // Default assumption for UAE\r\n\r\n        console.log('‚úÖ Extracted from filename:', { name, experience });\r\n\r\n        return {\r\n            name,\r\n            email: '',\r\n            phone: '',\r\n            experience,\r\n            skills,\r\n            licenses,\r\n            location: 'UAE',\r\n            rawText: `Data extracted from filename: ${filename}`\r\n        };\r\n    }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    console.log('üéØ PARSE API CALLED - Starting parsing process...');\r\n\r\n    try {\r\n        const { fileId } = await request.json();\r\n        console.log('üìÅ File ID received:', fileId);\r\n\r\n        if (!fileId) {\r\n            console.log('‚ùå No file ID provided');\r\n            return NextResponse.json({ error: 'File ID required' }, { status: 400 });\r\n        }\r\n\r\n        // Read our database\r\n        console.log('üìñ Reading database...');\r\n        const dbData = await readFile('./uploads/database.json', 'utf-8');\r\n        const database = JSON.parse(dbData);\r\n        console.log('üìä Database files count:', database.files?.length || 0);\r\n\r\n        // Find the file record\r\n        const fileRecord = database.files.find((f: any) => f.id === fileId);\r\n\r\n        if (!fileRecord) {\r\n            console.log('‚ùå File record not found for ID:', fileId);\r\n            return NextResponse.json({ error: 'File not found' }, { status: 404 });\r\n        }\r\n\r\n        console.log('‚úÖ File found:', fileRecord.originalName);\r\n        console.log('üìÑ File details:', {\r\n            mimetype: fileRecord.mimetype,\r\n            size: fileRecord.fileSize,\r\n            path: fileRecord.filePath\r\n        });\r\n\r\n        // Read the uploaded file\r\n        console.log('üìñ Reading file from disk...');\r\n        const fileBuffer = await readFile(fileRecord.filePath);\r\n        console.log('‚úÖ File read successfully, size:', fileBuffer.length, 'bytes');\r\n\r\n        let extractedText = '';\r\n\r\n        // Parse based on file type using REAL parsers\r\n        if (fileRecord.mimetype === 'application/pdf') {\r\n            console.log('üîß Starting PDF parsing...');\r\n            extractedText = await RealParser.parsePDF(fileBuffer);\r\n        } else if (fileRecord.mimetype.includes('word')) {\r\n            console.log('üîß Starting DOCX parsing...');\r\n            extractedText = await RealParser.parseDOCX(fileBuffer);\r\n        } else {\r\n            console.log('‚ùå Unsupported file type:', fileRecord.mimetype);\r\n            return NextResponse.json(\r\n                { error: 'Unsupported file type for parsing' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        console.log('‚úÖ File parsing completed, extracted text length:', extractedText.length);\r\n\r\n        // Extract structured data using REAL extraction\r\n        console.log('üîß Starting data extraction...');\r\n        const candidateData = RealParser.extractCandidateData(extractedText, fileRecord.originalName);\r\n\r\n        // Update database with parsed data\r\n        if (!database.candidates) database.candidates = [];\r\n\r\n        const candidateRecord = {\r\n            id: `candidate-${Date.now()}`,\r\n            fileId: fileRecord.id,\r\n            ...candidateData,\r\n            parsedAt: new Date().toISOString()\r\n        };\r\n\r\n        database.candidates.push(candidateRecord);\r\n\r\n        // Update file status\r\n        fileRecord.status = 'parsed';\r\n        fileRecord.parsedAt = new Date().toISOString();\r\n\r\n        // Save updated database\r\n        console.log('üíæ Saving updated database...');\r\n        const { writeFile } = await import('fs/promises');\r\n        await writeFile('./uploads/database.json', JSON.stringify(database, null, 2));\r\n\r\n        console.log(`‚úÖ Successfully parsed real CV: ${candidateRecord.name}`);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            candidate: candidateRecord,\r\n            message: 'CV parsed successfully with real data extraction'\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå PARSING API CRITICAL ERROR:', error);\r\n\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: 'Parsing failed',\r\n                details: error instanceof Error ? error.message : 'Unknown error'\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}"],"names":[],"mappings":"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"}}]
}